import streamlit as st
import requests
import os
import re
import pandas as pd
from openai import OpenAI
import tempfile
import subprocess
from io import BytesIO
import time
import random

# --- æ ¸å¿ƒé…ç½®åŒº (å®‰å…¨è¯»å–) ---
try:
    # å°è¯•è¯»å–
    SILICONFLOW_API_KEY = st.secrets["SILICONFLOW_API_KEY"]
    PARSING_API_URL = st.secrets["PARSING_API_URL"]

    # ğŸ” è°ƒè¯•æ‰“å°ï¼šå¦‚æœè¿™ä¸€è¡Œèƒ½æ˜¾ç¤ºåœ¨ç½‘é¡µä¸Šï¼Œè¯´æ˜ Secrets è¯»å–æˆåŠŸ
    st.warning(f"æ­£åœ¨ä½¿ç”¨çš„è§£ææ¥å£: [{PARSING_API_URL}]")
    st.info(f"Keyé•¿åº¦æ£€æŸ¥: {len(SILICONFLOW_API_KEY)} ä½")

except Exception as e:
    st.error(f"âŒ å¯åŠ¨å¤±è´¥: {e}")
    st.error("è¯·æ£€æŸ¥ .streamlit/secrets.toml (æœ¬åœ°) æˆ– Streamlit Cloud Secrets (äº‘ç«¯)ã€‚")
    st.stop()
# ---------------------------------------

st.set_page_config(page_title="æ‰¹é‡è§†é¢‘è½¬æ–‡å­—å·¥å…·", layout="wide")

SILICONFLOW_BASE_URL = "https://api.siliconflow.cn/v1"
ASR_MODEL = "iic/SenseVoiceSmall"

# UA æ± 
USER_AGENTS = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Safari/605.1.15",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36"
]

def get_random_header():
    return {
        "User-Agent": random.choice(USER_AGENTS),
        "Referer": "https://www.douyin.com/"
    }

def extract_url(text):
    if not text:
        return None
    pattern = r'(https?://[^\s]+)'
    match = re.search(pattern, text)
    return match.group(1) if match else None

def download_video_via_api(douyin_url, parser_api_url, status_callback=None):
    # é‡è¯•å‚æ•°
    MAX_RETRIES_PARSE = 3
    MAX_RETRIES_DOWNLOAD = 3
    
    # 1. è§£æé˜¶æ®µé‡è¯•
    video_url = None
    parse_error = None
    
    if '?' in parser_api_url:
        api_full_url = f"{parser_api_url}&url={douyin_url}"
    else:
        api_full_url = f"{parser_api_url}?url={douyin_url}"
        
    for i in range(MAX_RETRIES_PARSE):
        try:
            if i > 0 and status_callback:
                status_callback(f":gray[è¿æ¥ä¸ç¨³å®šï¼Œæ­£åœ¨é‡è¯•... ({i+1}/{MAX_RETRIES_PARSE})]")
            
            headers_parse = get_random_header()
            response = requests.get(api_full_url, headers=headers_parse, timeout=15)
            response.raise_for_status()
            data = response.json()
            
            if isinstance(data, dict):
                if "data" in data and isinstance(data["data"], dict):
                    video_url = data["data"].get("url") or data["data"].get("play_addr")
                elif "url" in data:
                    video_url = data["url"]
                elif "video_url" in data:
                    video_url = data["video_url"]
            
            if video_url:
                break # æˆåŠŸæ‹¿åˆ° URL
            else:
                parse_error = f"æœªæ‰¾åˆ°è§†é¢‘ URL. è¿”å›: {str(data)[:200]}"
                time.sleep(3) # è§£æå¤±è´¥ç­‰å¾…
                
        except Exception as e:
            parse_error = str(e)
            time.sleep(3) # å¼‚å¸¸ç­‰å¾…
            
    if not video_url:
        return None, f"è§£æå½»åº•å¤±è´¥: {parse_error}"

    # 2. ä¸‹è½½é˜¶æ®µé‡è¯•
    temp_dir = tempfile.mkdtemp()
    mp4_path = os.path.join(temp_dir, "video.mp4")
    download_success = False
    download_error = None
    
    for i in range(MAX_RETRIES_DOWNLOAD):
        try:
            if i > 0 and status_callback:
                status_callback(f":gray[è¿æ¥ä¸ç¨³å®šï¼Œæ­£åœ¨é‡è¯•... ({i+1}/{MAX_RETRIES_DOWNLOAD})]")
                
            headers_download = get_random_header()
            video_resp = requests.get(video_url, headers=headers_download, stream=True, timeout=30)
            video_resp.raise_for_status()
            
            with open(mp4_path, "wb") as f:
                for chunk in video_resp.iter_content(chunk_size=8192):
                    f.write(chunk)
            
            download_success = True
            break
        except Exception as e:
            download_error = str(e)
            time.sleep(5) # ä¸‹è½½å¤±è´¥ç­‰å¾…
            
    if not download_success:
        return None, f"ä¸‹è½½å½»åº•å¤±è´¥: {download_error}"

    # 3. è½¬ç éŸ³é¢‘
    try:
        mp3_path = os.path.join(temp_dir, "audio.mp3")
        command = [
            "ffmpeg", "-y",
            "-i", mp4_path,
            "-vn",
            "-acodec", "libmp3lame",
            "-q:a", "4",
            mp3_path
        ]
        subprocess.run(command, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        os.remove(mp4_path) # ç«‹å³åˆ é™¤ mp4
        return mp3_path, "ok"
    except Exception as e:
        if os.path.exists(mp4_path):
            os.remove(mp4_path)
        return None, f"è½¬ç å¤±è´¥: {str(e)}"

def transcribe_audio(client, file_path):
    try:
        with open(file_path, "rb") as audio_file:
            transcription = client.audio.transcriptions.create(
                model=ASR_MODEL,
                file=audio_file
            )
        return transcription.text
    except Exception as e:
        return f"è½¬å½•å¤±è´¥: {str(e)}"

# --- UI ä¾§è¾¹æ ï¼ˆä»…ä¿ç•™è¾“å…¥åŒºåŸŸï¼‰ ---
uploaded_file = st.sidebar.file_uploader("Excel/CSV æ‰¹é‡ä¸Šä¼ ", type=["xlsx", "xls", "csv"])
input_text = st.sidebar.text_area("æˆ–è¾“å…¥é“¾æ¥ (ä¸€è¡Œä¸€ä¸ª)", height=100)

# --- UI ä¸»ç•Œé¢ ---
st.title("æ‰¹é‡è§†é¢‘è½¬æ–‡å­—å·¥å…·")

if st.button("å¼€å§‹å¤„ç†", type="primary"):
    valid_urls = []
    if input_text.strip():
        lines = input_text.strip().split("\n")
        for line in lines:
            url = extract_url(line)
            if url:
                valid_urls.append(url)
    if uploaded_file is not None:
        try:
            if uploaded_file.name.endswith(".csv"):
                df_upload = pd.read_csv(uploaded_file)
            else:
                df_upload = pd.read_excel(uploaded_file)
            for _, row in df_upload.iterrows():
                row_str = " ".join(row.astype(str).values)
                url = extract_url(row_str)
                if url:
                    valid_urls.append(url)
        except Exception as e:
            st.error(f"è¯»å–æ–‡ä»¶å¤±è´¥: {e}")
    valid_urls = list(set(valid_urls))
    
    if not valid_urls:
        st.warning("è¯·å…ˆè¾“å…¥è§†é¢‘é“¾æ¥æˆ–ä¸Šä¼ æ–‡ä»¶")
    elif not SILICONFLOW_API_KEY:
        st.error("é…ç½®é”™è¯¯ï¼šAPI Key ä¸ºç©ºï¼Œè¯·æ£€æŸ¥ .streamlit/secrets.toml")
    else:
        client = OpenAI(api_key=SILICONFLOW_API_KEY, base_url=SILICONFLOW_BASE_URL)
        results = []
        progress_bar = st.progress(0)
        status_text = st.empty()
        total = len(valid_urls)
        
        for i, url in enumerate(valid_urls):
            current_progress_text = f"æ­£åœ¨å¤„ç†: {url} (è¿›åº¦ {i+1}/{total})"
            status_text.text(current_progress_text)
            
            # å®šä¹‰å›è°ƒå‡½æ•°æ›´æ–° UI çŠ¶æ€
            def update_status(msg):
                status_text.markdown(msg) # ä½¿ç”¨ markdown æ”¯æŒé¢œè‰²
                
            audio_path, err = download_video_via_api(url, PARSING_API_URL, status_callback=update_status)
            
            if audio_path and os.path.exists(audio_path):
                # çŠ¶æ€ä¿æŒæ˜¾ç¤ºæ­£åœ¨å¤„ç†ï¼Œä¸åˆ·å±
                transcript = transcribe_audio(client, audio_path)
                results.append({
                    "åŸå§‹é“¾æ¥": url,
                    "çŠ¶æ€": "æˆåŠŸ" if not transcript.startswith("è½¬å½•å¤±è´¥") else "å¤±è´¥",
                    "è§†é¢‘é€å­—ç¨¿": transcript if not transcript.startswith("è½¬å½•å¤±è´¥") else ""
                })
                try:
                    os.remove(audio_path)
                    os.rmdir(os.path.dirname(audio_path))
                except:
                    pass
            else:
                st.error(f"å¤±è´¥: {url}")
                results.append({
                    "åŸå§‹é“¾æ¥": url,
                    "çŠ¶æ€": "å¤±è´¥",
                    "è§†é¢‘é€å­—ç¨¿": ""
                })
            
            progress_bar.progress((i + 1) / total)
            
            # é˜²é£æ§ï¼šéšæœºå»¶æ—¶ (é™é»˜å¤„ç†ï¼Œä¸æ˜¾ç¤ºå€’è®¡æ—¶å¹²æ‰°ç”¨æˆ·)
            if i < total - 1:
                sleep_time = random.uniform(2, 5)
                time.sleep(sleep_time)

        status_text.text("å¤„ç†å®Œæˆ")
        
        if results:
            df = pd.DataFrame(results)
            
            # å¯¼å‡ºæŒ‰é’®ç½®äºè¡¨æ ¼ä¸Šæ–¹
            buffer = BytesIO()
            with pd.ExcelWriter(buffer, engine="openpyxl") as writer:
                df.to_excel(writer, index=False, sheet_name="transcripts")
                
            st.download_button(
                label="å¯¼å‡ºç»“æœ (Excel)",
                data=buffer.getvalue(),
                file_name="transcripts.xlsx",
                mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                type="primary"
            )
            
            st.dataframe(df, hide_index=True)
